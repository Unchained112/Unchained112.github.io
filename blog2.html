<!DOCTYPE HTML>
<html>

<head>
    <title>C++ and Algorithms for Interview</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
    <link rel="stylesheet" href="assets/css/main.css" />
    <link rel="icon" href="images/logo.png" />
</head>

<body class="is-preload">

    <!-- Header -->
    <section id="header">
        <header>
            <span class="image avatar"><img src="images/avatar.png" alt="" /></span>
            <h1 id="logo"><a href="index.html">Bosen Cheng</a></h1>
            <p>Working hard towards my dream<br />
                towards Eudaimonia</p>
        </header>
        <nav id="nav">
            <ul>
                <li><a href="index.html" class="active">Back to Homepage</a></li>
            </ul>
        </nav>
        <footer>
            <ul class="icons">
                <li><a href="https://www.linkedin.com/in/chengbosen/" class="icon brands fa-linkedin"><span
                            class="label">LinkedIn</span></a></li>
                <li><a href="https://github.com/" class="icon brands fa-github"><span class="label">Github</span></a>
                </li>
                <li><a href="mailto: chengbosen112@gmail.com" class="icon solid fa-envelope"><span
                            class="label">Email</span></a></li>
            </ul>
        </footer>
    </section>

    <!-- Wrapper -->
    <div id="wrapper">

        <!-- Main -->
        <div id="main">
            <div class="container">
                <header class="major">
                    <p> </p>
                    <h3 id="c-and-algorithms-for-interview">C++ and Algorithms for Interview</h3>
                </header>
                <h3 id="small-points">Small points</h3>
                <ul>
                    <li><code>x++</code> increments the value of variable <code>x</code> <strong>after</strong>
                        processing the current statement. <code>x+=i++;</code> add <code>i</code> to <code>x</code> then
                        increase <code>i</code> by 1. </li>
                    <li><code>++x</code> increments the value of <code>x</code> <strong>before</strong> processing the
                        current statement. <code>x+=++i;</code> increase <code>i</code> and add <code>i+1</code> to
                        <code>x</code>.
                    </li>
                    <li>Array is passed by reference. <code>array = &amp;array[0]</code>.</li>
                    <li>Reference must be initialized using a variable of the same type.</li>
                    <li>Enumerate example:
                        <pre><code><span class="hljs-keyword">enum</span> Suit_t {A, B, C, D};
<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> Name[] = {<span class="hljs-string">"A"</span>, <span class="hljs-string">"B"</span>, <span class="hljs-string">"C"</span>, <span class="hljs-string">"D"</span>};
<span class="hljs-keyword">enum</span> Suit_t x = C;
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; Name[x] &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
</code></pre>
                    </li>
                </ul>
                <h3 id="function-pointer">Function pointer</h3>
                <p>For functions that have precisely the same type signature, a function pointer allow us to call them
                    the same way from a syntactic point of view.</p>
                Example:
                <pre><code><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">min</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>;
<span class="hljs-comment">// EFFECTS: returns the smaller of a and b.</span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">max</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>;
<span class="hljs-comment">// EFFECTS: returns the larger of a and b.</span>

<span class="hljs-keyword">int</span> (*foo)(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>);

<span class="hljs-comment">// Then we can let foo = min or max and call</span>
foo(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">//for example</span>
</code></pre>
                <h3 id="memory">Memory</h3>
                <ul>
                    <li>Memory leak is caused when not recycling an allocated dynamic object.</li>
                    <li>Check memory leak: <code>valgrind --leak-check=full ./program &lt;args&gt;</code></li>
                    <li>The space for objects created via <code>new</code> comes from heap.</li>
                    <li>Stack is for function calls.</li>
                    <li><img src="./images/virtual-memory.jpg" alt="Memory segmentation" style="width: 100%"></li>
                </ul>
                <h3 id="struct-and-class">Struct and class</h3>
                <ul>
                    <li>
                        <p>The default copy constructor is shallow copy, which works when there is not points in the
                            member of that data type. </p>
                    </li>
                    <li>
                        <p>The sizeof for a struct is not always equal to the sum of sizeof of each individual member.
                            This is because of the padding added by the compiler to avoid alignment issues. Padding is
                            only added when a structure member is followed by a member with a larger size or at the end
                            of the structure.</p>
                        <ul>
                            <li>Different compilers might have different alignment constraints as C standards state that
                                alignment of structure totally depends on the implementation.</li>
                            <li>
                                Example: (output: &quot;Size of struct 24&quot;)
                                <pre><code><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
<span class="hljs-keyword">struct</span> A {
  <span class="hljs-comment">// sizeof(int) = 4</span>
  <span class="hljs-keyword">int</span> x;
  <span class="hljs-comment">// Padding of 4 bytes</span>

  <span class="hljs-comment">// sizeof(double) = 8</span>
  <span class="hljs-keyword">double</span> z;

  <span class="hljs-comment">// sizeof(short int) = 2</span>
  <span class="hljs-keyword">short</span> <span class="hljs-keyword">int</span> y;
  <span class="hljs-comment">// Padding of 6 bytes</span>
};

<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Size of struct: %ld"</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> A));

<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
                                <p><img src="./images/struct_sizeof_ep.png" alt="Size of struct" style="width: auto"></p>
                            </li>
                        </ul>
                        <ul>
                            <li>The size of the class is similar to the struct with little difference.<ul>
                                    <li>Empty class has size 1 (byte).</li>
                                    <li>The virtual function pointer has size of 4 bytes.</li>
                                    <li>The size of sub-class is equals to the size of all members plus the size of its
                                        parent class. (Note that they share the virtual function pointers) </li>
                                </ul>
                            </li>
                            <li>Notice on subclass method:
                                <pre><code><span class="hljs-type">PosIntSet</span> s; // sub <span class="hljs-keyword">class</span> <span class="hljs-keyword">instance</span> <span class="hljs-keyword">of</span> <span class="hljs-keyword">class</span> <span class="hljs-type">Intset</span>
<span class="hljs-type">IntSet</span> *p = s; // this points precisely to s
<span class="hljs-type">IntSet</span> &amp;r = s; // r is declared to be â€œreference to an <span class="hljs-type">IntSet</span>
// <span class="hljs-type">Apparent</span> <span class="hljs-class"><span class="hljs-keyword">type</span>: the declared <span class="hljs-keyword">type</span> of the reference. (<span class="hljs-type">IntSet</span>)</span>
// <span class="hljs-type">Actual</span> <span class="hljs-class"><span class="hljs-keyword">type</span>: the real <span class="hljs-keyword">type</span> of the referent. (<span class="hljs-type">PosIntSet</span>)</span>
// <span class="hljs-type">Actual</span> <span class="hljs-class"><span class="hljs-keyword">type</span>: the real <span class="hljs-keyword">type</span> of the referent. (<span class="hljs-type">PosIntSet</span>)</span>
</code></pre>
                            </li>
                        </ul>
                    </li>
                    <li>Virtual function and virtual table</li>
                    <li><img src="./images/vtable.png" alt="Vatble" style="width: 100%"></li>
                    <li>Note that the constructor function cannot be a virtual function since when instantiating an
                        object, it allocates no memory for that and then there would be no virtual table.</li>
                </ul>
                <h3 id="standard-template-library-stl-">Standard Template Library (STL)</h3>
                <p>The Standard Template Library (STL) is a set of C++ template classes to provide common programming
                    data structures and functions such as lists, stacks, arrays, etc. It is a library of container
                    classes, algorithms, and iterators. </p>
                <ul>
                    <li>Containers or container classes store objects and data. <ul>
                            <li>Sequence Containers: implement data structures which can be accessed in a sequential
                                manner. (vector, list, deque, etc)</li>
                            <li>Container Adaptors : provide a different interface for sequential containers. (queue,
                                stack, etc)</li>
                            <li>Associative Containers : implement sorted data structures that can be quickly searched
                                (O(log n) complexity). (set, map, multiset, etc)</li>
                            <li>Unordered Associative Containers : implement unordered data structures that can be
                                quickly searched. (unordered_set, unordered_multiset,
                                unordered_map, all introduced in C++11)</li>
                        </ul>
                    </li>
                </ul>
                <ul>
                    <li>
                        <p>Algorithms are a collections of implemented functions that operate on containers. For
                            example, there are sorting and searching functions like <code>sort()</code> and
                            <code>binary_search()</code>.
                        </p>
                    </li>
                    <li>
                        Iterators are used to point at the memory addresses of STL sequence containers.
                        <pre><code><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; ar = { <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span> };
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;::iterator ptr = ar.begin();
</code></pre>
                    </li>
                    <li>
                        Functors are objects that can be treated as though they are a function or function
                        pointer.
                        <pre><code><span class="hljs-comment">// A Functor</span>
<span class="hljs-keyword">class</span> <span class="hljs-title">increment</span> {
<span class="hljs-keyword">private</span>:
    <span class="hljs-keyword">int</span> num;
<span class="hljs-keyword">public</span>:
    increment(<span class="hljs-keyword">int</span> n) : num(n) {  }

    <span class="hljs-comment">// This operator overloading enables calling</span>
    <span class="hljs-comment">// operator function () on objects of increment</span>
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">operator</span> (<span class="hljs-params"></span>) (<span class="hljs-params"><span class="hljs-keyword">int</span> arr_num</span>) <span class="hljs-keyword">const</span> </span>{
        <span class="hljs-keyword">return</span> num + arr_num;
    }
};

The line,
transform(arr, arr+n, arr, increment(to_add));

<span class="hljs-keyword">is</span> the same <span class="hljs-keyword">as</span> writing below two lines,
<span class="hljs-comment">// Creating object of increment</span>
<span class="hljs-function">increment <span class="hljs-title">obj</span>(<span class="hljs-params">to_add</span>)</span>; 

<span class="hljs-comment">// Calling () on object</span>
transform(arr, arr+n, arr, obj);
</code></pre>

                        <h3 id="c-11-new-features">C++ 11 new features</h3>
                        <ol>
                            <li>
                                Automatic Type Deduction:
                                &quot;auto&quot; allow the complier to deduce the actual type of a variable, making
                                the coding more simple. For example:
                                <pre><code> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">map</span>;
 <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it = begin(<span class="hljs-built_in">map</span>); it != end(<span class="hljs-built_in">map</span>); ++it) {
 }
</code></pre>
                            </li>
                            <li>
                                <p><code>nullptr</code> replaces the <code>NULL</code>.</p>
                            </li>
                            <li>
                                Range-based for loop: more simple loop
                                <pre><code> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v = {<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>};

 <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; i : v) <span class="hljs-comment">// access by const reference</span>

 <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i : v) <span class="hljs-comment">// access by value, the type of i is int</span>
</code></pre>
                            </li>
                            <li>
                                Smart pointers:
                                <ul>
                                    <li>unique_ptr: should be used when ownership of a memory resource does not have to
                                        be shared (it doesn&#39;t have a copy constructor), but it can be transferred to
                                        another unique_ptr (move constructor exists).</li>
                                    <li>shared_ptr: should be used when ownership of a memory resource should be shared
                                        (hence the name).</li>
                                    <li>weak_ptr: holds a reference to an object managed by a shared_ptr, but does not
                                        contribute to the reference count; it is used to break dependency cycles (think
                                        of a tree where the parent holds an owning reference (shared_ptr) to its
                                        children, but the children also must hold a reference to the parent; if this
                                        second reference was also an owning one, a cycle would be created and no object
                                        would ever be released).</li>
                                </ul>
                            </li>
                            <li>
                                Lambdas: C++11 introduces lambdas allow users to write an inline, anonymous functor.
                                For example:
                                <pre><code> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">double</span>&gt;&amp; v)</span> </span>{
   <span class="hljs-built_in">std</span>::transform(v.begin(), v.end(), v.begin(),
              [](<span class="hljs-keyword">double</span> d) { <span class="hljs-keyword">return</span> d &lt; <span class="hljs-number">0.00001</span> ? <span class="hljs-number">0</span> : d; }
              );
 }

 <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">double</span>&gt;&amp; v)</span> </span>{
   <span class="hljs-built_in">std</span>::transform(v.begin(), v.end(), v.begin(),
     [](<span class="hljs-keyword">double</span> d) -&gt; <span class="hljs-keyword">double</span> {
         <span class="hljs-keyword">if</span> (d &lt; <span class="hljs-number">0.0001</span>) {
             <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
         } <span class="hljs-keyword">else</span> {
             <span class="hljs-keyword">return</span> d;
         }
     });
 }

 <span class="hljs-built_in">std</span>::function&lt;<span class="hljs-keyword">int</span>(<span class="hljs-keyword">int</span>)&gt; lfib = [&amp;lfib](<span class="hljs-keyword">int</span> n) {<span class="hljs-keyword">return</span> n &lt; <span class="hljs-number">2</span> ? <span class="hljs-number">1</span> : lfib(n<span class="hljs-number">-1</span>) + lfib(n<span class="hljs-number">-2</span>);};
</code></pre>
                            </li>
                            <li>
                                R-value reference: C++11 adds a new type of reference called an r-value reference. An
                                r-value reference is a reference that is designed to be initialized with an r-value
                                (only).
                                <pre><code> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>   s1     = <span class="hljs-string">"Hello "</span>;
 <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>   s2     = <span class="hljs-string">"world"</span>;
 <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp;&amp; s_rref = s1 + s2;    <span class="hljs-comment">// the result of s1 + s2 is an rvalue</span>
 s_rref += <span class="hljs-string">", my friend"</span>;           <span class="hljs-comment">// I can change the temporary string!</span>
 <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; s_rref &lt;&lt; <span class="hljs-string">'\n'</span>;       <span class="hljs-comment">// prints "Hello world, my friend"</span>
</code></pre>
                            </li>
                            <li>
                                <p>Thread: the class <code>std::thread</code> represents a single thread of execution.
                                    Threads allow multiple functions to execute concurrently.</p>
                            </li>
                        </ol>
                        <h3 id="reference-for-part-1">Reference for C++ part</h3>
                        <ol>
                            <li>Problem Solving with C++ (8th Edition), by Walter Savitch, Addison Wesley Publishing
                                (2011)</li>
                            <li><a href="https://www.geeksforgeeks.org/">https://www.geeksforgeeks.org/</a></li>
                            <li><a
                                    href="https://www.codeproject.com/Articles/570638/Ten-Cplusplus11-Features-Every-Cplusplus-Developer">https://www.codeproject.com/Articles/570638/Ten-Cplusplus11-Features-Every-Cplusplus-Developer</a>
                            </li>
                            <li><a href="https://en.cppreference.com/w/">https://en.cppreference.com/w/</a></li>
                        </ol>
                        <h3 id="data-structures">Data structures</h3>
                        <p>Data structure is a storage that is used to store and organize data. It is a way of arranging
                            data on a computer so that it can be accessed and updated efficiently. </p>
                        <p>I will not discuss about basic data structures including array, queue, linked list, and
                            stack. One can easily utilize the data structure through C++ STL. Two images below offer a
                            clear view of those data structures and features.</p>
                        <p><img src="./images/stl_data1.png" alt="Adaptive Unordered" style="width: 100%">
                            <img src="./images/stl_data2.png" alt="Sequence Ordered" style="width: 100%">
                        </p>
                        <p>We will take a closer look into some data structures, hash table, and binary tree, and their
                            extensions. </p>
                        <h4 id="hash-table">Hash table</h4>
                        <p>The hash table stores elements in key-value pair. Key is the unique integer that is used for
                            indexing the values. Value is the data that are associated with the corresponding key.</p>
                        <p><strong>Hash function</strong></p>
                        <p>In a hash table, a new index is processed using the keys. And, the element corresponding to
                            that key is stored in the index. This process is called hashing. </p>
                        <p>A good hash function may not prevent the collisions completely however it can reduce the
                            number of collisions. For example: </p>
                        <ol>
                            <li>Hashing by modulo: <code>h(k) = k % m;</code> for k is a key and m is the size.</li>
                            <li>Hashing by multiplication:
                                <pre><code>A = <span class="hljs-comment">(sqrt(5)</span> - <span class="hljs-number">1</span>)/<span class="hljs-number">2</span>;
<span class="hljs-comment">// we define that kA % 1 gives the fractional part kA.</span>
h<span class="hljs-comment">(k)</span> = floor<span class="hljs-comment">(m * ((k * A)</span> <span class="hljs-meta">%</span> <span class="hljs-number">1</span>));
</code></pre>
                            </li>
                        </ol>
                        <p><strong>Hash Collision</strong></p>
                        <p>Collision occurs when the hash function maps two or more items (keys) with different search
                            keys into the same bucket or index. There are two major schemes for solving the collision:
                            separate chaining and open addressing. In chaining, if a hash function produces the same
                            index for multiple elements, these elements are stored in the same index by using a
                            doubly-linked list. Unlike chaining, open addressing doesn&#39;t store multiple elements
                            into the same slot. Here, each slot is either filled with a single key or left. For example,
                            In linear probing, collision is resolved by checking the next slot.</p>
                        <h4 id="trees">Trees</h4>
                        <p>A tree is a nonlinear hierarchical data structure that consists of nodes connected by edges.
                            Some definitions are listed here:</p>
                        <ul>
                            <li>Root: It is the topmost node of a tree.</li>
                            <li>Height of a Node: The height of a node is the number of edges from the node to the
                                deepest leaf (ie. the longest path from the node to a leaf node).</li>
                            <li>Depth of a Node: The depth of a node is the number of edges from the root to the node.
                            </li>
                            <li>Height of a Tree: The height of a Tree is the height of the root node or the depth of
                                the deepest node.</li>
                        </ul>
                        <p><img src="./images/binaryTree.png" alt="Binary Tree"></p>
                        <p><strong>Binary Tree</strong></p>
                        <p>A binary tree is a tree data structure in which each parent node can have at most two
                            children. Example code:</p>
                        <pre><code><span class="hljs-comment">// Binary Search Tree operations in C++</span>

#include &lt;iostream&gt;
using namespace std;

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span></span> {
  <span class="hljs-keyword">int</span> key;
  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span></span> *left, *right;
};

<span class="hljs-comment">// Create a node</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span></span> *newNode(<span class="hljs-keyword">int</span> item) {
  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span></span> *temp = (<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span></span> *)malloc(<span class="hljs-keyword">sizeof</span>(<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span></span>));
  temp-&gt;key = item;
  temp-&gt;left = temp-&gt;right = NULL;
  <span class="hljs-keyword">return</span> temp;
}

<span class="hljs-comment">// Inorder Traversal</span>
void inorder(<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span></span> *root) {
  <span class="hljs-keyword">if</span> (root != NULL) {
    <span class="hljs-comment">// Traverse left</span>
    inorder(root-&gt;left);

    <span class="hljs-comment">// Traverse root</span>
    cout &lt;&lt; root-&gt;key &lt;&lt; <span class="hljs-string">" -&gt; "</span>;

    <span class="hljs-comment">// Traverse right</span>
    inorder(root-&gt;right);
  }
}

<span class="hljs-comment">// Insert a node</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span></span> *insert(<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span></span> *node, <span class="hljs-keyword">int</span> key) {
  <span class="hljs-comment">// Return a new node if the tree is empty</span>
  <span class="hljs-keyword">if</span> (node == NULL) <span class="hljs-keyword">return</span> newNode(key);

  <span class="hljs-comment">// Traverse to the right place and insert the node</span>
  <span class="hljs-keyword">if</span> (key &lt; node-&gt;key)
    node-&gt;left = insert(node-&gt;left, key);
  <span class="hljs-keyword">else</span>
    node-&gt;right = insert(node-&gt;right, key);

  <span class="hljs-keyword">return</span> node;
}

<span class="hljs-comment">// Find the inorder successor</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span></span> *minValueNode(<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span></span> *node) {
  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span></span> *current = node;

  <span class="hljs-comment">// Find the leftmost leaf</span>
  <span class="hljs-keyword">while</span> (current &amp;&amp; current-&gt;left != NULL)
    current = current-&gt;left;

  <span class="hljs-keyword">return</span> current;
}

<span class="hljs-comment">// Deleting a node</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span></span> *deleteNode(<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span></span> *root, <span class="hljs-keyword">int</span> key) {
  <span class="hljs-comment">// Return if the tree is empty</span>
  <span class="hljs-keyword">if</span> (root == NULL) <span class="hljs-keyword">return</span> root;

  <span class="hljs-comment">// Find the node to be deleted</span>
  <span class="hljs-keyword">if</span> (key &lt; root-&gt;key)
    root-&gt;left = deleteNode(root-&gt;left, key);
  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key &gt; root-&gt;key)
    root-&gt;right = deleteNode(root-&gt;right, key);
  <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// If the node is with only one child or no child</span>
    <span class="hljs-keyword">if</span> (root-&gt;left == NULL) {
      <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span></span> *temp = root-&gt;right;
      free(root);
      <span class="hljs-keyword">return</span> temp;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root-&gt;right == NULL) {
      <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span></span> *temp = root-&gt;left;
      free(root);
      <span class="hljs-keyword">return</span> temp;
    }

    <span class="hljs-comment">// If the node has two children</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span></span> *temp = minValueNode(root-&gt;right);

    <span class="hljs-comment">// Place the inorder successor in position of the node to be deleted</span>
    root-&gt;key = temp-&gt;key;

    <span class="hljs-comment">// Delete the inorder successor</span>
    root-&gt;right = deleteNode(root-&gt;right, temp-&gt;key);
  }
  <span class="hljs-keyword">return</span> root;
}

<span class="hljs-comment">// Driver code</span>
<span class="hljs-keyword">int</span> main() {
  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span></span> *root = NULL;
  root = insert(root, <span class="hljs-number">8</span>);
  root = insert(root, <span class="hljs-number">3</span>);
  root = insert(root, <span class="hljs-number">1</span>);
  root = insert(root, <span class="hljs-number">6</span>);
  root = insert(root, <span class="hljs-number">7</span>);
  root = insert(root, <span class="hljs-number">10</span>);
  root = insert(root, <span class="hljs-number">14</span>);
  root = insert(root, <span class="hljs-number">4</span>);

  cout &lt;&lt; <span class="hljs-string">"Inorder traversal: "</span>;
  inorder(root);

  cout &lt;&lt; <span class="hljs-string">"\nAfter deleting 10\n"</span>;
  root = deleteNode(root, <span class="hljs-number">10</span>);
  cout &lt;&lt; <span class="hljs-string">"Inorder traversal: "</span>;
  inorder(root);
}
</code></pre>
                        <p><strong>Heap</strong></p>
                        <p>Heap is a complete <strong>binary tree</strong> that satisfies the heap property, where any
                            given node is:</p>
                        <ul>
                            <li>always greater than its child node/s and the key of the root node is the largest among
                                all other nodes. This property is also called max heap property.</li>
                            <li>always smaller than the child node/s and the key of the root node is the smallest among
                                all other nodes. This property is also called min heap property.</li>
                        </ul>
                        <p>When using the heap, the following are the basic operations used:</p>
                        <ul>
                            <li>Heapify: Return a heap data structure given an input binary tree.</li>
                            <li>Insert: Insert a new element.</li>
                            <li>Delete: delete the selected element.</li>
                        </ul>
                        <p>Example code:</p>
                        <pre><code><span class="hljs-comment">// Max-Heap data structure in C++</span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *a, <span class="hljs-keyword">int</span> *b)</span>
</span>{
  <span class="hljs-keyword">int</span> temp = *b;
  *b = *a;
  *a = temp;
}
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">heapify</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &amp;hT, <span class="hljs-keyword">int</span> i)</span>
</span>{
  <span class="hljs-keyword">int</span> size = hT.size();
  <span class="hljs-keyword">int</span> largest = i;
  <span class="hljs-keyword">int</span> l = <span class="hljs-number">2</span> * i + <span class="hljs-number">1</span>;
  <span class="hljs-keyword">int</span> r = <span class="hljs-number">2</span> * i + <span class="hljs-number">2</span>;
  <span class="hljs-keyword">if</span> (l &lt; size &amp;&amp; hT[l] &gt; hT[largest])
    largest = l;
  <span class="hljs-keyword">if</span> (r &lt; size &amp;&amp; hT[r] &gt; hT[largest])
    largest = r;

  <span class="hljs-keyword">if</span> (largest != i)
  {
    swap(&amp;hT[i], &amp;hT[largest]);
    heapify(hT, largest);
  }
}
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &amp;hT, <span class="hljs-keyword">int</span> newNum)</span>
</span>{
  <span class="hljs-keyword">int</span> size = hT.size();
  <span class="hljs-keyword">if</span> (size == <span class="hljs-number">0</span>)
  {
    hT.push_back(newNum);
  }
  <span class="hljs-keyword">else</span>
  {
    hT.push_back(newNum);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = size / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)
    {
      heapify(hT, i);
    }
  }
}
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">deleteNode</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &amp;hT, <span class="hljs-keyword">int</span> num)</span>
</span>{
  <span class="hljs-keyword">int</span> size = hT.size();
  <span class="hljs-keyword">int</span> i;
  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; size; i++)
  {
    <span class="hljs-keyword">if</span> (num == hT[i])
      <span class="hljs-keyword">break</span>;
  }
  swap(&amp;hT[i], &amp;hT[size - <span class="hljs-number">1</span>]);

  hT.pop_back();
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = size / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)
  {
    heapify(hT, i);
  }
}
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printArray</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &amp;hT)</span>
</span>{
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; hT.size(); ++i)
    <span class="hljs-built_in">cout</span> &lt;&lt; hT[i] &lt;&lt; <span class="hljs-string">" "</span>;
  <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"\n"</span>;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
  <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; heapTree;

  insert(heapTree, <span class="hljs-number">3</span>);
  insert(heapTree, <span class="hljs-number">4</span>);
  insert(heapTree, <span class="hljs-number">9</span>);
  insert(heapTree, <span class="hljs-number">5</span>);
  insert(heapTree, <span class="hljs-number">2</span>);

  <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Max-Heap array: "</span>;
  printArray(heapTree);

  deleteNode(heapTree, <span class="hljs-number">4</span>);

  <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"After deleting an element: "</span>;

  printArray(heapTree);
}
</code></pre>
                        <p>There are also other more complex tree structures such as AVL tree and Red-Black tree, check
                            reference to read more about this.</p>
                        <h3 id="algorithms">Algorithms</h3>
                        <p>Algorithm is a step-by-step procedure, which defines a set of instructions to be executed in
                            a certain order to get the desired output. </p>
                        <h3 id="reference-for-part-2">Reference for part 2</h3>
                        <ol>
                            <li><a
                                    href="https://www.geeksforgeeks.org/the-c-standard-template-library-stl/">https://www.geeksforgeeks.org/the-c-standard-template-library-stl/</a>
                            </li>
                            <li><a href="https://www.programiz.com/dsa">https://www.programiz.com/dsa</a></li>
                        </ol>


            </div>
        </div>


    </div>

    <!-- Scripts -->
    <script src="assets/js/jquery.min.js"></script>
    <script src="assets/js/jquery.scrollex.min.js"></script>
    <script src="assets/js/jquery.scrolly.min.js"></script>
    <script src="assets/js/browser.min.js"></script>
    <script src="assets/js/breakpoints.min.js"></script>
    <script src="assets/js/util.js"></script>
    <script src="assets/js/main.js"></script>

</body>

</html>