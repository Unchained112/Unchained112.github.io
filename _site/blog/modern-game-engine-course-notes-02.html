<!DOCTYPE html>

<!--
  portfolYOU Jekyll theme by yousinix
  Free for personal and commercial use under the MIT license
  https://github.com/yousinix/portfolYOU
-->

<html lang="en" class="h-100">

<head>

  
  
  

  

  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <meta property="og:type" content="website">
  <meta property="og:title" content="Modern Game Engine Course Notes 02">
  <meta property="og:description" content="Modern Game Engine - From Getting Started To Practice is a free public course about game engine. This part focus on rendering techniques.">
  <meta property="og:image" content="https://i.imgur.com/WsyG08b.png">

  <title>Modern Game Engine Course Notes 02</title>
  <meta name="description" content="Modern Game Engine - From Getting Started To Practice is a free public course about game engine. This part focus on rendering techniques.">

  <link rel="shortcut icon" type="image/x-icon" href="/assets/favicon.ico">

  <!-- Theme style -->
  <script src="/assets/js/theme.js"></script>

  <!-- Font Awesome CDN -->
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.4/css/all.css">

  <!-- Bootstrap CSS CDN -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/css/bootstrap.min.css">

  <!-- Animate CSS CDN -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.7.0/animate.css">

  <!-- Custom CSS -->
  <link rel="stylesheet" href="/assets/css/style.css">

</head>


<body class="h-100 d-flex flex-column">

  <main class="flex-shrink-0 container mt-5">
    <nav class="navbar navbar-expand-lg navbar-themed">

  <a class="navbar-brand" href="/"><h5><b>Bosen Cheng</b></h5></a>

  <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation">
    <i class="fas fa-1x fa-bars text-themed"></i>
  </button>

  <div class="collapse navbar-collapse" id="navbarNavAltMarkup">
    <div class="navbar-nav ml-auto"><a class="nav-item nav-link " href="/projects/">Projects</a>

      <a class="nav-item nav-link active" href="/blog/">Blog</a>

      <a class="nav-item nav-link " href="/about/">About</a>

      

      <span id="theme-toggler" class="nav-item nav-link" role="button" onclick="toggleTheme()"></span>
    </div>
  </div>

</nav>
    <div class="col-lg-10 mx-auto mt-5 markdown-body">
  <h1><b>Modern Game Engine Course Notes 02</b></h1>

<p class="post-metadata text-muted">
  26 October 2022 -  
  <b>12 mins read time</b>

  <br>Tags: 
    
    <a class="text-decoration-none no-underline" href="/blog/tags#computer-graphics">
      <span class="tag badge badge-pill text-primary border border-primary">Computer Graphics</span>
    </a>
    
    <a class="text-decoration-none no-underline" href="/blog/tags#game-engine">
      <span class="tag badge badge-pill text-primary border border-primary">Game Engine</span>
    </a>
    
    <a class="text-decoration-none no-underline" href="/blog/tags#technology">
      <span class="tag badge badge-pill text-primary border border-primary">Technology</span>
    </a>
    </p>

<p>Course from: <a href="https://games104.boomingtech.com/sc/">BoomingTech</a></p>

<h2 id="rendering-on-game-engine">Rendering on Game Engine</h2>

<p>A heavily optimized practical software framework to fulfill the critical rendering requirements of games on modern hardware (PC, console and mobiles).</p>

<p><img src="/assets/GameEngine/OutlineofRendering.png" alt="Outline of Rendering" /></p>

<h3 id="building-blocks-of-rendering">Building Blocks of Rendering</h3>

<p>Pipeline and data: Vertex Data -&gt; Triangle Data -&gt; Material Parameters -&gt; Textures</p>
<ul>
  <li>Projection Transform and Rasterization</li>
  <li>Shading</li>
  <li>Texture Sampling</li>
</ul>

<h3 id="understand-the-hardware">Understand the Hardware</h3>

<p>SIMD and SIMT 
Single Instruction Multiple Data
Single Instruction Multiple Threads</p>

<p>GPU Architecture</p>

<p><img src="/assets/GameEngine/GPUArch.png" alt="GPU Arch" /></p>

<p>Data Flow from CPU to GPU</p>

<ul>
  <li>CPU and Main Memory: Data load / unload; Data preparation</li>
  <li>CPU to GPU: High latency / Limited Bandwidth</li>
  <li>GPU and Video Memory: High Performance Parallel Rendering</li>
</ul>

<p><em>Try not to read memory from GPU</em></p>

<h3 id="gpu-bounds-and-performance">GPU Bounds and Performance</h3>

<p>Application performance is limited by:</p>
<ul>
  <li>Memory bounds</li>
  <li>ALU bounds</li>
  <li>TMU (Texture Mapping Unit) bounds</li>
  <li>BW ( Bandwidth) bounds</li>
</ul>

<h3 id="renderable">Renderable</h3>

<p>Game object - Components - Mesh Render Component.</p>

<p>Vertex and Index Buffer: Vertex data is accessed through index.</p>

<p>Materials: determine the appearance of objects, and how objects interact with light.</p>
<ul>
  <li>Phong Model</li>
  <li>PBR Model</li>
  <li>Subsurface Material</li>
</ul>

<p>Various Textures in Materials: Albedo, Normal, Metallic, Roughness, AO.</p>

<p>Variety of Shaders</p>

<h3 id="render-objects-in-engine">Render Objects in Engine</h3>

<p>Model assets are made based on local coordinate systems, and eventually are rendered in screen space through transformation and projection.</p>

<p>Display different textures on a single model with submesh!</p>

<p>Resource pool: Instance - use handle to reuse resources</p>

<p><strong>Definition and Instance, vital concept for game engine!</strong></p>

<p>Within a scene, using resource pools, all the materials are sorted.</p>

<p>GPU Batch Rendering.</p>

<h3 id="visibility-culling">Visibility Culling</h3>

<p>For each view, there are a lot of objects which are not needed to be rendered.</p>

<p>Using the simplest bound to create culling (BVH, PVS Potential Visibility Set).</p>

<p>Construction and Insertion of BVH in Game Engine</p>

<h3 id="texture-compression">Texture Compression</h3>

<p>Traditional image compression like JPG and PNG</p>
<ul>
  <li>Good compression rates</li>
  <li>Image quality</li>
  <li>Designed to compress or decompress an entire image</li>
</ul>

<p>In game texture compression</p>
<ul>
  <li>Decoding speed</li>
  <li>Random access</li>
  <li>Compression rate and visual quality - Encoding speed</li>
</ul>

<p>Common block-based compression format</p>
<ul>
  <li>On PC, BC7 (modern) or DXTC (old) formats</li>
  <li>On mobile, ASTC (modern) or ETC / PVRTC (old) formats</li>
</ul>

<h3 id="cluster-based-mesh-pipeline">Cluster-Based Mesh Pipeline</h3>

<p>Nanite:</p>
<ul>
  <li>Hierarchical LOD clusters with seamless boundary</li>
  <li>Donâ€™t need hardware support, but using a hierarchical cluster culling on the precomputed BVH tree by persistent threads (CS) on GPU instead of task shader</li>
</ul>

<h2 id="lighting-materials-and-shaders">Lighting, Materials and Shaders</h2>

<p>Lighting</p>
<ul>
  <li>Photon emit, bounce, absorb and perception is the origin of everything in rendering.</li>
</ul>

<p>Material</p>
<ul>
  <li>How matter react to photon</li>
</ul>

<p>Shader</p>
<ul>
  <li>How to train and organize those micro-slaves to finish such a vast and dirty computation job between photon and materials</li>
</ul>

<p>The Rendering Equation
<img src="/assets/GameEngine/RenderingEq.png" alt="Rendering Equation" /></p>

<p>The 1st Challenge: How to get incoming radiance for any given incoming direction.</p>
<ul>
  <li>1a Visibility to Lights</li>
  <li>1b Light Source Complexity (point light, direction light)</li>
</ul>

<p>The 2nd Challenge: Integral of lighting and scatting function on hemisphere is expensive.
<img src="/assets/GameEngine/2ndChallenge.png" alt="2nd Challenge" /></p>

<p>The 3rd Challenge: To evaluate incoming radiance, we have to compute yet another integral, i.e. rendering equation is recursive.
<img src="/assets/GameEngine/3rdChallenge.png" alt="3rd Challenge" /></p>

<h3 id="blinn-phong-model-simple-and-useful">Blinn-Phong Model: Simple and Useful</h3>

<p>Ambient + Diffuse + Specular = Blinn-Phong Reflection</p>

<p><code class="language-plaintext highlighter-rouge">L = k_a * I_a + k_d * (I / r^2) + k_s * * (I / r^2) * max(0, dot(N, H))^2</code></p>

<p>Problem of Blinn-Phong:</p>
<ul>
  <li>The energy is not conservative: the reflected energy should not be greater than incoming energy; some materials cannot be properly modeled by artists</li>
</ul>

<h3 id="shadow">Shadow</h3>

<p>Already obsolete method: planar shadow, shadow volume, projective texture.</p>

<p>Shadow Map:
<img src="/assets/GameEngine/ShadowMap.png" alt="Shadow Map" /></p>

<h3 id="pre-computed-global-illumination">Pre-computed Global Illumination</h3>

<p>Lightmap:</p>
<ul>
  <li>Pros
    <ul>
      <li>Very efficient on runtime</li>
      <li>Bake a lot of fine details of GI on environment</li>
    </ul>
  </li>
  <li>Cons
    <ul>
      <li>Long and expensive precomputation (lightmap farm)</li>
      <li>Only can handle static scene and static light</li>
      <li>Storage cost on package and GPU</li>
    </ul>
  </li>
</ul>

<p>Light Probes + Reflection Probes</p>
<ul>
  <li>Pros
    <ul>
      <li>Very efficient on runtime</li>
      <li>Can be applied to both static and dynamic objects</li>
      <li>Handle both diffuse and specular shading</li>
    </ul>
  </li>
  <li>Cons
    <ul>
      <li>A bunch of SH light probes need some precomputation</li>
      <li>Can not handle fine detail of GI. I.e, soft shadow on overlapped structures</li>
    </ul>
  </li>
</ul>

<h3 id="physical-based-material">Physical-Based Material</h3>

<p>BRDF Model Based on Microfacet
<img src="/assets/GameEngine/BRDF.png" alt="BRDF" /></p>

<p>Disney Principled BRDF</p>

<p>Principles to follow when implementing model:</p>
<ul>
  <li>Intuitive rather than physical parameters should be used</li>
  <li>There should be as few parameters as possible</li>
  <li>Parameters should be zero to one over their plausible range</li>
  <li>Parameters should be allowed to be pushed beyond their plausible range where it makes sense</li>
  <li>All combinations of parameters should be as robust and plausible as possible</li>
</ul>

<p>PBR Specular Glossiness
<img src="/assets/GameEngine/PBR_SG.png" alt="BRDF" /></p>

<p>PBR Metallic Roughness</p>

<p><strong>Two most important models for learners</strong></p>

<p>To find out more details by yourself: Image-Based Lighting (IBL), Cascade Shadow.</p>

<p>Summary of Popular AAA Rendering</p>
<ul>
  <li>Lightmap + Light probe</li>
  <li>PBR + IBL</li>
  <li>Cascade shadow + VSSM</li>
</ul>

<h3 id="the-challenges-and-fun-of-rendering-the-beautiful-mother-nature">The Challenges and Fun of Rendering the Beautiful Mother Nature</h3>

<p>Environment Components in Games:</p>

<ul>
  <li>Sky and Cloud</li>
  <li>Vegetation</li>
  <li>Terrain</li>
</ul>

<p><strong>Terrain</strong></p>

<ul>
  <li>Simple method: Heightfield - Mesh grids</li>
  <li>Adaptive Mesh Tessellation</li>
  <li>Two Golden Rules of Optimization
    <ul>
      <li>View-dependent error bound: Distance to camera FoV; Error compare to ground truth (pre-computation)</li>
    </ul>
  </li>
  <li>Triangle-based Subdivision
    <ul>
      <li>Subdivision and T-Junctions: Continuously partitioning triangles and their children based on the idea of binary trees</li>
    </ul>
  </li>
  <li>QuadTree-Based Subdivision (used more common in the industry)
    <ul>
      <li>Pros: Easy to construct; Easy management of data under geospatial, including objects culling and data streaming</li>
      <li>Cons: Mesh subdivision is not as flexible as triangle mesh; The grid level of the leaf nodes needs to beconsistent</li>
      <li>Solve T-Junctions among Quad Grids: Mesh LoD Stitching</li>
    </ul>
  </li>
  <li>Triangulate Irregular Network (TIN)</li>
  <li>
    <p>Real-Time Deformable Terrain</p>
  </li>
  <li>Non-Heightfield Terrain</li>
  <li>Dig a Hole in Terrain: Cull a terrain vertex by outputting NaN from the vertex shader</li>
  <li>
    <p>Crazy Idea - Volumetric Representation: Marching Cubes</p>
  </li>
  <li>Paint Terrain Material</li>
  <li>Advanced Texture Splatting: Blending with Height (add bias)</li>
  <li>Sampling from Material Texture Array</li>
  <li>
    <p>Parallax and Displacement Mapping</p>
  </li>
  <li>Virtual Texture
    <ul>
      <li>Build a virtual indexed texture to represent all blended terrain materials for whole scene</li>
      <li>Only load materials data of tiles based on view- depend LOD</li>
      <li>Pre-bake materials blending into tile and store them into physical textures</li>
    </ul>
  </li>
  <li>VT Implementation, DirectStorage &amp; DMA</li>
  <li>Floating-point Precision Error</li>
  <li>Camera-Relative Rendering
    <ul>
      <li>Translates objects by the negated world space camera position before any other geometric transformations affect them</li>
      <li>It then sets the world space camera position to 0 and modifies all relevant matrices accordingly</li>
    </ul>
  </li>
</ul>

<p><strong>Vegetation</strong></p>

<ul>
  <li>Tree Rendering: Tree LOD: From mesh to billboard</li>
  <li>Decorator Rendering</li>
  <li>Road and Decals Rendering:
    <ul>
      <li>Spline-based Roda Editing and Sculpturing Height Field</li>
      <li>Splatting Road and Decals on Virtual Texture</li>
    </ul>
  </li>
</ul>

<p><strong>Sky</strong></p>

<p><img src="/assets/GameEngine/AnaylticSky.png" alt="Analytic Atmosphere Appearance Modeling" /></p>

<p>Participating Media</p>
<ul>
  <li>Volume filled with particles</li>
  <li>Interact differently with light depending on its composition</li>
</ul>

<p><img src="/assets/GameEngine/ParticipatingMedia.png" alt="Participating Media" /></p>

<p><img src="/assets/GameEngine/VRE.png" alt="Volume Rendering Equation" /></p>

<p>Real Physics in Atmosphere</p>

<p>Scattering Types</p>
<ul>
  <li>Rayleigh Scattering: Scattering of light by particles that have a diameter much smaller than the wavelength of the radiation (eg. air molecules).</li>
  <li>Mie scattering: Scattering of light by particles that have a diameter similar to or larger than the wavelength of the incident light (eg. aerosols).</li>
</ul>

<p>Variant Air Molecules Absorption</p>
<ul>
  <li>Ozone (O3): Absorb strongly at longer wavelengths to filter out the reds, oranges, yellows</li>
  <li>Methane (CH4): Well-known for absorbing red light</li>
</ul>

<p>Ray Marching</p>
<ul>
  <li>Ray marching is a popular method to integrate function along a path</li>
  <li>We use ray marching to calculate final radiance for a given point by single scattering</li>
  <li>The integrated radiance is usually stored in look-up tables (LUT)</li>
</ul>

<p>Precomputed Atmospheric Scattering</p>

<p>Those knowledge is too complex for me to understand, thus I just link the reference for further reading:</p>

<ul>
  <li><a href="https://ebruneton.github.io/precomputed_atmospheric_scattering/">https://ebruneton.github.io/precomputed_atmospheric_scattering/</a></li>
  <li><a href="https://diglib.eg.org/bitstream/handle/10.1111/cgf14050/v39i4pp013-022.pdf">A Scalable and Production Ready Sky and Atmosphere Rendering Technique</a></li>
</ul>

<p><strong>Cloud</strong></p>

<p>Billboard Cloud</p>

<ul>
  <li>Pros
    <ul>
      <li>Efficient</li>
    </ul>
  </li>
  <li>Cons
    <ul>
      <li>Limited visual effect</li>
      <li>Limited cloud type</li>
    </ul>
  </li>
</ul>

<p>Volumetric Cloud Modeling</p>

<ul>
  <li>Pros
    <ul>
      <li>Realistic cloud shapes</li>
      <li>Large scale clouds possible</li>
      <li>Dynamic weather supported</li>
      <li>Dynamic volumetric lighting and shadowing</li>
    </ul>
  </li>
  <li>Cons
    <ul>
      <li>Efficiency must be considered</li>
    </ul>
  </li>
</ul>

<p>Noise Function</p>

<ul>
  <li>Perlin Noise</li>
  <li>Worley Noise: Voronoi</li>
</ul>

<p>Cloud Density Model</p>

<p><img src="/assets/GameEngine/RayMarchingCloud.png" alt="Ray Marching Cloud" /></p>

<h2 id="render-pipeline-post-process-and-everything">Render Pipeline, Post-process and Everything</h2>

<h3 id="ambient-occlusion">Ambient Occlusion</h3>

<p><img src="/assets/GameEngine/AO.png" alt="Ambient Occlusion" /></p>

<p>Precomputed AO: Using ray tracing to compute the AO offline and store the result into texture, which is widely used in object modeling process</p>
<ul>
  <li>Extra storage cost</li>
  <li>Only apply to static object</li>
</ul>

<p>Screen Space Ambient Occlusion (SSAO)</p>
<ul>
  <li>Generate N random samples in a sphere around each pixel p in view space</li>
  <li>Test sample occlusions by comparing depth against depth buffer</li>
  <li>Average visibility of sample points to approximate AO</li>
</ul>

<p>SSAO+</p>
<ul>
  <li>Recall the AO equation is acutally done on the normal-oriented hemisphere</li>
</ul>

<p>HBAO Horizon-based Ambient Occlusion</p>
<ul>
  <li>Use the depth buffer as a heightfield on 2D surface</li>
  <li>Rays that below the horizon angle are occluded</li>
  <li>Trace rays directly in 2D and approximate AO from horizon angle</li>
</ul>

<p>GTAO - Ground Truth-based Ambient Occlusion</p>
<ul>
  <li>GTAO introduces the missing cosine factor, removes the attenuation function, and add a fast approximation of multi bounce</li>
  <li>Add multiple bounces by fitting a cubic polynomial per albedo</li>
</ul>

<p>Ray-Tracing Ambient Occlusion</p>
<ul>
  <li>Casting rays from each screen pixel using RTT hardware
    <ul>
      <li>1 spp(sample per-pixel) works well for far-field occlusion</li>
      <li>With 2-4 spp, can recover detailed occlusion in contact region</li>
    </ul>
  </li>
</ul>

<h3 id="fog">Fog</h3>

<p>Depth Fog</p>
<ul>
  <li>Linear fog: <code class="language-plaintext highlighter-rouge">factor = (end-z)/(end-start)</code></li>
  <li>Exp fog: <code class="language-plaintext highlighter-rouge">factor = exp(- density*z)</code></li>
  <li>Exp Squared fog: <code class="language-plaintext highlighter-rouge">factor = exp(- (density*z)^2)</code></li>
</ul>

<p>Height Fog
<img src="/assets/GameEngine/HeightFog.png" alt="Height Fog" /></p>

<p>Voxel-based Volumetric Fog</p>
<ul>
  <li>Clip space volumes
    <ol>
      <li>Material properties &lt;= (Input data: Participating media entities)</li>
      <li>Froxel light scattering &lt;= (Input data: Lighting and shadow information)</li>
      <li>Final integration</li>
    </ol>
  </li>
</ul>

<h3 id="anti-aliasing">Anti-aliasing</h3>

<p>Reason of Aliasing</p>
<ul>
  <li>Aliasing is a series of rendering artifact which is caused by high-frequency signal vs. insufficient sampling of limited rendering resolutions</li>
</ul>

<p>Anti-aliasing</p>
<ul>
  <li>The general strategy of screen-based antialiasing schemes is using a sampling pattern to get more samples and then weight and sum samples to produce a pixel color</li>
</ul>

<p>Super-sample AA (SSAA) and Multi-sample AA (MSAA)</p>
<ul>
  <li>SSAA, 4x rendering resolution 4x z-buffer and framebuffer, 4x rasterization and pixel shading</li>
  <li>MSAA, only multi-sampling necessary pixels 4x z-buffer and framebuffer, 4x rasterization and 1+ x pixel shading</li>
</ul>

<p>FXAA (Fast Approximate Anti-aliasing)</p>
<ul>
  <li>Anti-aliasing based on 1x rendered image
    <ul>
      <li>Find edge pixels by luminance</li>
      <li>Compute offset for every edge pixel</li>
      <li>Re-sample edge pixel by its offset to blend with a neighbor</li>
    </ul>
  </li>
</ul>

<p>TAA (Temporal Anti-aliasing)</p>
<ul>
  <li>Utilize spatial-temporal filtering methods to improve AA stability in motion</li>
</ul>

<h3 id="post-process">Post-process</h3>

<p>Post-process in 3D Graphics refers to any algorithm that will be applied to the final image. It can be done for stylistic reasons (color correction, contrast, etc.) or for realistic reasons (tone mapping, depth of field, etc.)</p>

<p>What is Bloom</p>
<ul>
  <li>The physical basis of bloom is that, in the real world, lenses can never focus perfectly</li>
  <li>Even a perfect lens will convolve the incoming image with an Airy disk</li>
</ul>

<p>Bloom</p>
<ol>
  <li>Detect Bright Area by Threshold</li>
  <li>Gaussian Blur / Pyramid Gaussian Blur</li>
  <li>Bloom Composite</li>
</ol>

<h3 id="tone-mapping">Tone Mapping</h3>

<ul>
  <li>No way to directly display HDR image in a SDR device</li>
  <li>The purpose of the Tone Mapping function is to map the wide range of high dynamic range (HDR) colors into standard dynamic range (SDR) that a display can output</li>
</ul>

<p><img src="/assets/GameEngine/FilmicCurve.png" alt="Filmic Curve" /></p>

<p>ACES Academy Color Encoding System</p>
<ul>
  <li>Primarily for Film &amp; Animation</li>
  <li>Interesting paradigms and transformations</li>
</ul>

<p>The useful bits</p>
<ul>
  <li>Applying Color Grading in HDR is good</li>
  <li>The idea of a fixed pipeline up to the final OTD transforms stage is good</li>
  <li>Separates artistic intent from the mechanics of supporting different devices</li>
</ul>

<p>HDR and SDR Pipeline</p>
<ul>
  <li>Visual consistency between HDR / SDR</li>
  <li>Similar SDR results to previous SDR color pipeline</li>
  <li>High quality</li>
  <li>High performance</li>
  <li>Minimal disruption to art teams
    <ul>
      <li>Simple transition from current color pipeline</li>
      <li>Minimal additional overhead for mastering HDR and SDR</li>
    </ul>
  </li>
</ul>

<h3 id="color-grading">Color Grading</h3>

<p>Lookup Table (LUT)</p>
<ul>
  <li>LUT is used to remap the input color values of source pixels to new output values based on data contained within the LUT</li>
  <li>A LUT can be considered as a kind of color preset that can be applied to image or footage</li>
</ul>

<h3 id="rendering-pipeline">Rendering Pipeline</h3>

<p>Rendering pipeline is the management order of all rendering operation execution and resource allocation</p>

<p>Forward rendering</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for n meshes 
    for m lights
        color += shading(mesh, light)
</code></pre></div></div>

<p>Sort and Render Transparent after Opaque Objects</p>

<p>Deferred Rendering</p>

<p><img src="/assets/GameEngine/DeferredRendering.png" alt="Deferred Rendering" /></p>

<ul>
  <li>Pros
    <ul>
      <li>Lighting is only computed for visible fragments</li>
      <li>The data from the G-Buffer can be used for post-</li>
      <li>processing</li>
    </ul>
  </li>
  <li>Cons
    <ul>
      <li>High memory and bandwidth cost</li>
      <li>Not supporting transparent object</li>
      <li>Not friendly to MSAA</li>
    </ul>
  </li>
</ul>

<p>Advanced rendering techniques for further reading:</p>
<ul>
  <li>Tile-based Rendering (used in mobile devices)</li>
  <li>Forward+ (Tile-based Forward) Rendering</li>
  <li>Cluster-based Rendering</li>
  <li>Visibility Buffer (more triangle faces than pixels)</li>
</ul>

<p>Challenges</p>
<ul>
  <li>Complex parallel work needs to synchronize with complex resource dependency</li>
  <li>Large amount of transient resource whose lifetime is shorter than one frame</li>
  <li>Complex resource state management</li>
  <li>Exploit newly exposed GPU features without extensive user low level knowledge</li>
</ul>

<p>Advanced solutions for further reading</p>
<ul>
  <li>Frame Graph: A Directed Acyclic Graph (DAG) of pass and resource dependency in a frame, not a real visual graph</li>
</ul>

<p>Render to monitor</p>
<ul>
  <li>V-Sync technology</li>
  <li>Variable Refresh Rate</li>
</ul>




</div>
  </main>
  <footer class="mt-auto py-3 text-center">

  <small class="text-muted mb-2">
    <i class="fas fa-code"></i> with <i class="fas fa-heart"></i>
    by <strong>Bosen Cheng</strong>
  </small>

  <div class="container-fluid justify-content-center"><a class="social mx-1"  href="mailto:chengbosen112@gamil.com"
       style="color: #6c757d"
       onMouseOver="this.style.color='#db4437'"
       onMouseOut="this.style.color='#6c757d'">
      <i class="fas fa-envelope fa-1x"></i>
    </a><a class="social mx-1"  href="https://www.github.com/Unchained112"
       style="color: #6c757d"
       onMouseOver="this.style.color='#333333'"
       onMouseOut="this.style.color='#6c757d'">
      <i class="fab fa-github fa-1x"></i>
    </a><a class="social mx-1"  href="https://www.linkedin.com/in/chengbosen"
       style="color: #6c757d"
       onMouseOver="this.style.color='#007bb5'"
       onMouseOut="this.style.color='#6c757d'">
      <i class="fab fa-linkedin-in fa-1x"></i>
    </a>

</div><small id="attribution">
    theme <a href="https://github.com/yousinix/portfolYOU">portfolYOU</a>
  </small>

</footer>

  
  <!-- GitHub Buttons -->
<script async defer src="https://buttons.github.io/buttons.js"></script>

<!-- jQuery CDN -->
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>

<!-- Popper.js CDN -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.6/umd/popper.min.js"></script>

<!-- Bootstrap JS CDN -->
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js"></script>

<!-- wow.js CDN & Activation -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/wow/1.1.2/wow.js"></script>
<script> new WOW().init(); </script>

<!-- Initialize all tooltips -->
<script>
$(function () {
    $('[data-toggle="tooltip"]').tooltip()
})
</script>
</body>

</html>